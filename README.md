# UCTests 
 UCTests - это библиотека для автоматизированного тестирования вашего приложения согласно созданным use cases как ваше приложение видят пользователи (тестировщики).
 
 По сути это инструментальные тесты в которых происходит подмена части базовых классов андроида на болванки удобные для проведения тестов  
 
## Интеграция
Библиотека поставляется в виде 2-х jar файлов - один (тестовый) используется исключительно для проведения тестов, второй (рабочий) для создания запускаемых версий (релизов и дебаг). Причем запустить приложение созданное с использованием тестовой версии нельзя - оно будет падать.

Чтобы разделить процесс сборки тестового и рабочего приложений надо в файле гредл добавить флейвор для тестов:

    flavorDimensions "main"
    productFlavors {
        fl1 {}
        fl2 {}

        forTest {}

    }
  
Если у вас еще нет в проекте флейворов то надо создать 1 для работы и добавить 1 для тестов

В разделе dependencies надо указать какой файл jar использовать в какой сборке - для всех настоящих флейворов надо указать рабочий файл, а для тестового тестовый:

    fl1Implementation fileTree(include: ['ucrelease.jar'], dir: 'libs')
    fl2Implementation fileTree(include: ['ucrelease.jar'], dir: 'libs')
    forTestImplementation fileTree(include: ['uctests.jar'], dir: 'libs')
 
В случае если у вас несколько зависимых модулей в проекте, то надо создать тестовый флейвор в каждом модуле, который может аффектиться тестируемым модулем.
 
Все, на этом интеграция завершена, надо запустить обычный билд и убедиться что все компилируется.

## Запуск тестов
Так как это инструментальные тесты, то надо в зависимости в гредл файле добавить 

    androidTestImplementation 'androidx.test:runner:1.1.1'
    androidTestImplementation 'androidx.test.ext:junit:1.1.0'

Сами тесты будут располагаться в папке *src/androidTest/java/packagename*

Файлы с тестами должны быть под аннотацией

    @RunWith(AndroidJUnit4::class)

причем эта аннотация должна быть из импорта *androidx.test.ext.junit.runners.AndroidJUnit4*

Каждая тестовая функция в этом классе должна быть с аннотацией

    @Test

Так как мы работаем с UI компонентами, то надо чтобы исполнялось все в потоке в котором есть возможность создавать хендлеры, а для них нужны луперы, активировать которые можно путем добавления в класс метода

    @Before
    fun before() {
        if (Looper.myLooper() == null)
            Looper.prepare()
    }

Подключение разных jar-файлов в процессе компилляции - дело не хитрое, но вот IDE об этом ничего не знает, и ей надо четко указать на какой файл сейчас ориентироваться. Если этого не сделать то IDE не будет видеть нужных классов для тестирования. Сделать это можно в конфигурации проекта - слева на экране IDE есть закладка Build Variants - там вы увидите список модулей и какой из флейворов используется по-умолчанию - вот этот флейвор надо изменить на тестовый. После изменений флейвора чтобы IDE не сходила с ума надо сделать clean проекту, иначе гарантированы глюки редактора. Замечу что флейвор надо поменять на тестовый для всех зависимых модулей которых аффектит тест. В моем случае это forTestDebug. Позже, когда тесты будут прогнаны и вы захотите вернуться к работе - надо будет вернуть Build Variant в исходное состояние и опять сделать clean.

Для проверки что все успешно настроено и подключено можно написать простой тестик:

    fun EmptyTest() {
        val appContext = InstrumentationRegistry.getInstrumentation().targetContext

        val router = ActivityRouter(appContext, { null }, { it })
        router.startActivity(TestableActivity())
        assertEquals(1, router.getStackSize())
    }

Здесь создается роутер (главная часть тестовой системы), в ктором запускается пустое активити и идет проверка что активити запустилось. Если этот тест компиллируется то все в порядке.


## Как сделать Activity тестируемым
* Активити должно быть унаследованно от TestableActvity. При компилляции с рабочей версией библиотеки это класc будет заменен на AppCompatActivity. 
* Все View к которым идет доступ в коде должны использоваться как классы из библиотеки с аналогичными названиями но с суфиксом Unit, т.е. TextView превращается во TextViewUnit. При компилляции это бует заменено на настоящие View. Так что в рабочей версии никаких артефактов от библиотеки не будет. 
* XML менять не надо. Все лейауты должны быть как и раньше. Чтобы из лейаута достать View надо использовать функцию *findView<T:ViewUnit>* - такие функции есть у ViewUnit и у TestableActivity

## Запуск активити
* Для запуска первого активити надо создать класс-роутер в который надо передать контекст, фабрику моков активити, и фабрику моков фрагментов. В простых случаях фабрики можно передавать пустыми. Фабрика моков активитей нужна когда из тестируемого кода планируется перехватывать запуски каких-то внешних активити, которые не покрыты тестами, например логин фейсбука. Либо когда активити не поддается простому тестированию и должно быть заменено на мок. Фабрика фрагментов будет рассмотрена далее. 
* В коде для запуска любого активити надо сделать обычный интент и запустить обычными функциями.  

Фабрика активити это просто свитч по имени запускаемого активити, например 

    val mockFabric: (String) -> TestableActivity? = { activityName: String ->

        when (activityName) {
            Activity1::class.java.name -> Activity1Mock()
            else -> null
        }

    }

В случае если для запускаемого активити мок не нужен, то функция должна вернуть null. Для обычных активити, в которых нет специфическх компонентов (которые будут рассмотрены ниже), где для работы с UI используется только setContentView и findView - мок делать не надо.

## Запуск активити в котором есть UI контейнер 
Если при создании UI происходит что-то кастомное, например создание UI через Anko, то такие действия необходимо оборачивать в UI контейнер. В библиотеке есть заготовка для такого контейнера *UIContainerUnit*, но это лишь вариант унификации стиля кода и не имеет отношения к тестам. Такой контейнер удобен тем что его можно полностью заменить на мок при запуске тестов. Для этого надо создать поле ui этого класса в активити и создать мок, унаследовав его от главного активти, а в нем переопределить ui с контейнером унаследованным от UI контейнера и лишь заменить функцию создания внутренностей контейнера. См пример Activity1

## Работа с фрагментами
Работа с фрагментами сделана по самому простому сценарию - они просто активируются и складываются в кучку. Никаких пересечений, перекрытий, вложенностей, бекстеков фрагментов нет. Поэтому при отображении фрагмента важен тольк id лейаут-контейнера в который этот фрагмент помещается. 

Для отображения фрагмента предусмотрен специальный метод showFragment, в который надо передать сам фрагмент и id, по тому же id далее можно найти фрагмент и получить доступ к его UI.   

Сам тестируемый фрагмент должен быть унаследован от TestableFragment, при этом в случае простой работы с UI мокать ничего не требуется. Пример можно найти в Activity2.

Если же фрагмент содержит UI контейнер, то его можно мокнуть по аналогии с моком контейнеров в Activity, за тем лишь исключением что в фабрику моков фрагмент передается целиком, готовый, а не в виде интента, и потому для мока UI контейнера достаточно его пересоздать в фабрике, не создавая лишнего класса. Пример см в Activity3.

## Тестирование ViewPager
Простейшая работа с вьюпеджером заключается в создании каждого вью и ручном добавлении на экран. При этом сам вьюпейджер оперирует только с Item-ами, которые могут быть любым объектом, например контейнером UI или фрагментом. Для того чтобы сделать вьюпейджер тестируемым надо унаследовать свой адаптер от PagerAdapterUnit, а для инфлейта вьюшек необходимо использовать специальную функцию в адаптере - inflate. При тестировании ViewPager создаст все Item-ы сразу и далее можно получить доступ к UI по списку итемов vViewPager.items[i]. При этом нет разницы какой сейчас итем отображен на экране, они буд-то все есть и все видимы. См пример Activity4  

ВьюпейджерАдаптер для работы с фрагментами будет готов в ближайшее время

## Тестирование RecyclerView
В тестах работа рециклервью имитируется путем создания всех холдеров для всех итемов из списка как если бы все итемы поместились на экране одновременно. Это не критично по памяти поскольку все Unit легковесны и без проблем создадутся. Для тестирования необходимо свой адаптер унаследовать от RecyclerViewAdapterUnit а холдеры от RecyclerViewHolderUnit, кроме того для инфлейта вьюшек необходимо использовать функцию адаптера inflate. Доступ к UI итемов можно получить через vRecView.holders[i]. См пример Activity5

## Toast
Штатную функцию для отображения тостов вызывать нельзя - она упадет. Так что надо вызывать встроенную в TestableActivity toast или toastLong. Во время тестирования все тосты записываются в список, так что можно проверить что тост был через router.getActivity<Activity5>().toastList.last()

## Dialog-и
Диалог - по сути это готовый кусок UI и в него нельзя залезть, а значит надо относиться к ним как к неделимым сущностям. Тестированию они пока не поддаются и их надо избегать, закрывать интерфейсом.

## Сторонние библиотеки
Если в проекте используется сторонная библиотека с кастомными View, то надо сделать Unit для этого View в библиотеке и сымитировать ее деятельность. За добавлением этих юнитов обращайтесь к автору.

Если же сторонние библиотеки не имеют кастомных View, но каким-либо образом обращаются к UI, например библиотеки Picasso и Glide, то для тестирования надо изолировать их за интерфейсом.

## Запуск тестов в CI
Инструкция как запустить тесты при использовании Jenkins находится в разработке 